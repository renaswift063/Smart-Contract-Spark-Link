# ShillNFT



首先这个东西他的目的是为了解决，NFT传播的问题。
也就是是一个廉价版本的NFT，其特点为弱publisher，强shill。




第一步先是publisher
他先要发布自己的作品在上面，甚至都无所谓是不是他的作品。

这个时候调用的是publish函数
 
 传入参数是：



 emit的事件是：




 然后接下来会自动mint给他一个NFT，这个是根节点，只有一份，标号是1, father是0.


publisher有资格去设定shill次数和费率，并且不允许更改。


 需要考虑一下递减这种形式合不合适，这一点都不市场主导

可以有一个调整的低一些的方法么？


这个经济模型跑的通么


是否还要保留最低税率？
加入了一个loss_ratio
用于控制初次mint是一个递减的过程
这个是不是应该强制设置loss_ratio
royaltyfee 是否允许设置成0？

transfer的时候保留手续费是否合理
如果一个用户不借助我们合约所提供的交易的便利，那么他就可以transfer价格为0,与其他人达成私下的交易，或者赠送，那我们并没有理由对他进行收税。

那么在我们目前这个体系之中，主力到底是mint还是transfer。


前端应该可以溯源获取整个树形结构，所以emit的事件需要有足够的信息使得前端能够获取全部的树形结构的信息。

吸取明明哥提供的有关对于整个经济模型的贡献度的问题，如果有条件的话后续可能会改成这个树形结构可能会随着节点数量的不同发生一定程度上的旋转。

是否有必要限制一个节点的子节点数目


edition如何编号？
是否需要在issue里面记录一个总数？
因为这个模型其实很难在合约内处理我的子节点有哪些这个问题

前端有一个需求是
比如说有一个人shill给别人一个NFT的时候
出去的应该是这个人的NFT的id
那么需要有一个页面来查询这个人所拥有的所有的NFT
但我们现在只有通过NFT_id查询他的owner是谁的，但并没有查询他拥有哪些NFT的接口
那么这个我们又不愿意消耗gas费去把它存起来，所以最好的办法是写在log里把它loop出来
所以log里一定需要一个owner对NFT_id的记录，还要加上去transfer的


我还是觉得得直接从合约里查比较合理


删去了原有的publish转账不消耗royaltyfee，改为了父节点为0,转移少开一次transfer


可能会考虑自己调的话就绕过is_on_sale的check，这样就避免了赠送的时候也会收手续费，以及低价挂单被别人耗羊毛的情况。


不对劲目前的这一套并不存在链式传导的机制，而只是单纯的上家收了下家的费用

我需要记录每一个人在不同的NFT下的收入是多少，在claim的时候抽税，并发送给上级



设计上出现了一个不合理的地方，因为我要保持这个NFT的价值，所以说在publish issue的时候会传入一个shill_times参数，这个参数控制了每一个NFT的最多能够mint出来的子节点数量。
同时在合约创建时设置一个常量loss_ratio,每次通过shill mint出新的NFT的价格是一个由初始设定的first_shell_price，逐级乘以loss_ratio算出来的值。
这样的话shill_times控制了树不会横向生长，loss_ratio控制了树纵向生长的时候阅读内容(即获取新的下级NFT)是越来越便宜的，同时其价值是递减的，同样通过这种机制使得上级的NFT拥有被炒作的价值。
但是这样设置会出现一个伞兵的事情，也就是某个人拿着这个NFT，步道shill_times次之后，他就没理由继续步道了，所以这个是不利于体系生长的。
所以接下来的改进是，当cx到最后一次shill_times的时候，最后一个冤大头会mint出来两份NFT，一份给自己一份给父节点，然后父节点拿着这个向下了一级的NFT继续cx。
这个地方有两种选择，一种选择是这一份新的NFT也占一个，shill_times的名额，那么我们需要在publish的时候做修改（目前来说我们是允许发布不产生子节点的NFT的），同时这个收费也要做一些修改。
第二种选择这个就是内置的，也就是你用光了shill_times之后，会产生一个新的下级NFT，也就是某个节点最多拥有的下一级数量是(shill_times+1)，这个时候对shill_times初始设定成0的NFT也是OK的，他的最多字子节点数是0,因为这个产生下一级需要由acceptshill触发。
唯一的问题是，我在某个站点挂出来了一个shill的NFT，指向这个NFTID的链接，当次数用光之后，不会自动转移到我所拥有的子节点。
还有一个不算问题的问题，就是当父节点很强的时候，这个树会单向生长，但我觉得这个没啥问题。


发现了一个安全问题，claim的时候没有做owner检查，但好像又没什么问题，那是累计收益，transfer之后不会再被计算了所以好像也OK，不用检查。


貌似我在每一个Edition里面设置一个奖金池，然后对一个单个NFT进行claim这个方法是OK的，代价是必须要一个一个得收米，也就是将claim和owner解耦，这样貌似就不会造成我需要弄个iterablemapping的问题了。

claim不再限制只有owner可以调取，而是只transfer给owner，在transfer函数中自动进行claim再transfer。
已经加入了上述的生长子节点的设定。


将safemath取消，因为好像0.8后版本自带safemath

随后可以加入issue与issue之间的关系，考虑二次创作，翻译等等的因素。

如果出现二次创作，是否可以通过用户自己修改这个NFT的URI来进行分叉？
比如说汉化之类的。

马哥提到有些创作者会不愿意去让自己的作品被分叉，那么可以在出版的时候进行设置。

前端提供真伪验证功能，也就是传入两个NFT_id（或者是自动的filter)判断时间出现的前后，类似与这样的，一方面防止publish的盗版，一方面是防止汉化之类的节点的盗版。

存在一个根节点一键收米的问题，可能需要提供这个接口。

is_on_sale是否是必要的？
对于用户来说他出售不出售这个NFT并不是有人愿意出价的一个必要条件
他不想卖他不approve不就行了么
我们合约只是用了一种去中心化的方式做了个opensea出来，也就是token自带一个交易功能而已。

增加一个lable功能，因为我们存在一个付费解锁的问题，还有就是咋说，我们对区块链的认知是，希望能够把好多数据公开了，那么实际上对这个内容的种类是什么之类的，也需要用户来打标记。
所以在每一份购买的NFT之中应该有一个lable

新加入需求，ERC20支持，扣去一定数量的MASK，允许用户创建新的合约，流通ERC20token

新加入需求，boardcast，即不再收取费用，而是将奖励打入奖金池。


新加入优化，determine price的部分可以做修改，首先删去is_on_sale flag使得用户在opensea上的交易更加顺滑，判断一下有没有这个必要。
其次可以将transfer的方法取消掉强制check，另外封装出来一个方法，里面用签名的方式从传入计价金额，中心化的存储或者分发，这样的话增强用户对平台的依赖性，取消掉determineprice的系列方法解耦transfer和二级市场买卖。

新加入andy的优化建议：
Hi， 我还在看代码，一点想法:
- transferFrom 和 safeTransferFrom 有不少代码是重复的，这部分我觉得可以改善一下
- 这份文件里不少函数是可以继承ERC721来的，例如： _mint， 我觉得可以改善一下（父类的函数保持不动），solidity是面向对象的语言。
- 可以lint一下solidity code
- _issueIds 有好几次类型转换，这种情况，我觉得可以直接用256 bit的ID，免去检查和类型转换
- _shill_times 类型是uint64, 就没必要再检查_shill_times <= max_64了


已经将transfer的问题解决，同时删除了TransferWithPrice的冗余问题

存在一个新的问题，我们现在没有支持burn操作，如果支持的话有一个下层的收益断层的问题，应该能够修改这些节点指向父亲的父亲。
但是我们合约并没有能够获取子节点的函数。


我们是否默认所有的调起我们的mint函数等等的msg.sender不会是0地址，也不会是合约地址。
所以说到底有没有必要去check一个目标地址是不是一个合约地址，合约地址拥有我们的NFT是不是可以的
有没有必要去做这个防呆，目前来看我们transfer是做了的，但是我们的mint应该是不需要的
他只会在两个地方做这个操作，一个是publish一个是acceptShill，那么这两个情况目前来看都不会是合约调起的。
(已处理，该部分已经删去，集成完成)

如果考虑盈利模型，那么在合约construct的时候我们加入一个合约所属的edition，在该奖金池中每次用户claim的时候抽取一定百分比加入奖金池。