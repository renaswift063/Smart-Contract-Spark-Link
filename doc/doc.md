# ShillNFT



首先这个东西他的目的是为了解决，NFT传播的问题。
也就是是一个廉价版本的NFT，其特点为弱publisher，强shill。




第一步先是publisher
他先要发布自己的作品在上面，甚至都无所谓是不是他的作品。

这个时候调用的是publish函数
 
 传入参数是：



 emit的事件是：




 然后接下来会自动mint给他一个NFT，这个是根节点，只有一份，标号是1, father是0.


publisher有资格去设定shill次数和费率，并且不允许更改。


 需要考虑一下递减这种形式合不合适，这一点都不市场主导

可以有一个调整的低一些的方法么？


这个经济模型跑的通么


是否还要保留最低税率？
加入了一个loss_ratio
用于控制初次mint是一个递减的过程
这个是不是应该强制设置loss_ratio
royaltyfee 是否允许设置成0？

transfer的时候保留手续费是否合理
如果一个用户不借助我们合约所提供的交易的便利，那么他就可以transfer价格为0,与其他人达成私下的交易，或者赠送，那我们并没有理由对他进行收税。

那么在我们目前这个体系之中，主力到底是mint还是transfer。


前端应该可以溯源获取整个树形结构，所以emit的事件需要有足够的信息使得前端能够获取全部的树形结构的信息。

吸取明明哥提供的有关对于整个经济模型的贡献度的问题，如果有条件的话后续可能会改成这个树形结构可能会随着节点数量的不同发生一定程度上的旋转。

是否有必要限制一个节点的子节点数目


edition如何编号？
是否需要在issue里面记录一个总数？
因为这个模型其实很难在合约内处理我的子节点有哪些这个问题

前端有一个需求是
比如说有一个人shill给别人一个NFT的时候
出去的应该是这个人的NFT的id
那么需要有一个页面来查询这个人所拥有的所有的NFT
但我们现在只有通过NFT_id查询他的owner是谁的，但并没有查询他拥有哪些NFT的接口
那么这个我们又不愿意消耗gas费去把它存起来，所以最好的办法是写在log里把它loop出来
所以log里一定需要一个owner对NFT_id的记录，还要加上去transfer的


我还是觉得得直接从合约里查比较合理


删去了原有的publish转账不消耗royaltyfee，改为了父节点为0,转移少开一次transfer


可能会考虑自己调的话就绕过is_on_sale的check，这样就避免了赠送的时候也会收手续费，以及低价挂单被别人耗羊毛的情况。


不对劲目前的这一套并不存在链式传导的机制，而只是单纯的上家收了下家的费用

我需要记录每一个人在不同的NFT下的收入是多少，在claim的时候抽税，并发送给上级



设计上出现了一个不合理的地方，因为我要保持这个NFT的价值，所以说在publish issue的时候会传入一个shill_times参数，这个参数控制了每一个NFT的最多能够mint出来的子节点数量。
同时在合约创建时设置一个常量loss_ratio,每次通过shill mint出新的NFT的价格是一个由初始设定的first_shell_price，逐级乘以loss_ratio算出来的值。
这样的话shill_times控制了树不会横向生长，loss_ratio控制了树纵向生长的时候阅读内容(即获取新的下级NFT)是越来越便宜的，同时其价值是递减的，同样通过这种机制使得上级的NFT拥有被炒作的价值。
但是这样设置会出现一个伞兵的事情，也就是某个人拿着这个NFT，步道shill_times次之后，他就没理由继续步道了，所以这个是不利于体系生长的。
所以接下来的改进是，当cx到最后一次shill_times的时候，最后一个冤大头会mint出来两份NFT，一份给自己一份给父节点，然后父节点拿着这个向下了一级的NFT继续cx。
这个地方有两种选择，一种选择是这一份新的NFT也占一个，shill_times的名额，那么我们需要在publish的时候做修改（目前来说我们是允许发布不产生子节点的NFT的），同时这个收费也要做一些修改。
第二种选择这个就是内置的，也就是你用光了shill_times之后，会产生一个新的下级NFT，也就是某个节点最多拥有的下一级数量是(shill_times+1)，这个时候对shill_times初始设定成0的NFT也是OK的，他的最多字子节点数是0,因为这个产生下一级需要由acceptshill触发。
唯一的问题是，我在某个站点挂出来了一个shill的NFT，指向这个NFTID的链接，当次数用光之后，不会自动转移到我所拥有的子节点。
还有一个不算问题的问题，就是当父节点很强的时候，这个树会单向生长，但我觉得这个没啥问题。


发现了一个安全问题，claim的时候没有做owner检查，但好像又没什么问题，那是累计收益，transfer之后不会再被计算了所以好像也OK，不用检查。


貌似我在每一个Edition里面设置一个奖金池，然后对一个单个NFT进行claim这个方法是OK的，代价是必须要一个一个得收米，也就是将claim和owner解耦，这样貌似就不会造成我需要弄个iterablemapping的问题了。

claim不再限制只有owner可以调取，而是只transfer给owner，在transfer函数中自动进行claim再transfer。
已经加入了上述的生长子节点的设定。


将safemath取消，因为好像0.8后版本自带safemath

随后可以加入issue与issue之间的关系，考虑二次创作，翻译等等的因素。

如果出现二次创作，是否可以通过用户自己修改这个NFT的URI来进行分叉？
比如说汉化之类的。

马哥提到有些创作者会不愿意去让自己的作品被分叉，那么可以在出版的时候进行设置。

前端提供真伪验证功能，也就是传入两个NFT_id（或者是自动的filter)判断时间出现的前后，类似与这样的，一方面防止publish的盗版，一方面是防止汉化之类的节点的盗版。

